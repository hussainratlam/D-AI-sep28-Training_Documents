#########################
Day - 9 | 16th Nov. 2024
#########################

	Container Orchestration Tool - Kubernetes
	
	
	Kubernetes :::
	
	Overview of Kubernetes
	
	Architecture of Kubernetes
	
	Components of Kubernetes Architecture
	
	Install and Configure Kubernetes Architecture
	
	Kubernetes Concepts 
	
	Real Time Scenarios & Usecases
	
	

	-	Overview of Kubernetes :
	
		- Is an Open-Source Container Orchestration Tool
		- Used to Deployment Containerized Micro-Service Based Application Services
		- Kubernetes is used to ensure high availability of the Containerized Application Services Deployed in Prod
		- By Creating Relicas
		- Self-Healing Capabilities
		- Kubernetes supports Auto-Scaling and Load Balancing
		- Continuous Deployment can be achived using the Kubernetes Deployment Strategies without any downtime
		
		- Kubernetes was owned by Google. 
		
		
		Docker -- 2013 -----> 2015 
		
		prod implementation 
		
		AWS 	-> ECS/ECR/EKS
		
		Azure	-> ACS/ACR/AKS
		
		GCP		-> GCE/GCR/GKE
		
		
		
	-	Architecture of Kubernetes
	
		- It is based on Kubernetes Master and WorkNodes.
		
	- Components of Kubernetes Architecture
	
		- API Server 
		- ETCD 
		- Scheduler
		- Controller Manager 
		
		- Kubelet
		- KubeProxy 
		- CRI - Container Runtime Interface - Container-D
		
	- Roles & Responsibilities ::
	
		- Kubernetes Developer 
		
		- Kubernetes Administrator
		
		- Kubernetes Security Administrator
	 
		
	- Kubernetes Concepts / Terminologies :::
	
		- Pods 					# Smallest/Atomic unit of task 
								# Pods exectute the Containers within
		
		- Container				# Executable unit of Container Images 
		
		- Images 				# Static file published in Container Registry 
								# This act as an input for deployment
		
		- Cluster 				# Is a collection of Kubernetes Worker-Nodes 
		
		- Manifest File 		# App Config File, that defines the properties of Pods for deployment
		
		
	Working with Kubernetes :
	
		
		Cluster 				# Is a collection of Kubernetes Worker-Nodes 
		
		Kubernetes Master (VM)			# Schedule and Control the Deployment of Pods / Also called as Control Plane.
		
			- Kubernetes WorkNode1(VM)	# Actually used to run the pods.
			- Kubernetes WorkNode2(VM)	# Actually used to run the pods.
			- Kubernetes WorkNode3(VM)	# Actually used to run the pods.			
			
			
		Kubectl 				# Is a Command Line Utility to interact with Kubernetes Master 
		
		Pods 					# Smallest/Atomic unit of task 				
		                        # Pods exectute the Containers within
								
								# Pods are Deployed 
								# Pod Networking 
								# Intra-Pod Networking
								# Inter-Pod Networking
								
								# Pods are not the permanent entities.
								# Once the pod is deleted that IP Address also removed from that pod. 
	

	
	Kubernetes Concepts :
	
		Pods 
		
		Controller Objects 
		
			- Replication Controller 
			- Replicaset 
			- Daemonset 
			- Deployment 
		
		Kubernetes Services :
		
			- NodePort Service 
			- ClusterIP 
			- Load Balancer 
			
		Kubernetes Volumes :
			- ConfigMap Volume
			- Secret Volume 
			- HostPath Volume 
			- Persistant Volumes 
			- Persistant Volume Claim 
			
		NameSpaces			# Logical grouping of Kubernetes Cluster 
		
		HELM Chart 
								
	

	- Install and Configure Kubernetes Master Node and Worker Nodes :::
	
		Kubernetes Master (VM)			
        
        	- Kubernetes WorkNode1(VM)	
        	- Kubernetes WorkNode2(VM)	
			
			
		Using Kubeadm 
		
		https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/
		

		Pods 
		
		
		kubectl get nodes 
		
		kubectl get pods 
		
		kubectl get pods --all-namespaces
		
		kubectl get ns 
		

	Create/Deploy Pods :
	
	
	Manifest File : --> yaml/json 
	
		apiversion:
		kind:
		metadata:
		spec:
		
		
Next :::

	- Create/Deploy Pods : with eg. 
	
	- Login to the Pod 
	
		- kubectl exec -it 
	
	- Access the Applications running inside the port using web-browser
	
		- Nodeport service 
	
	Controller Objects 
	
		- Replication Controller 
		- Replicaset 
		- Daemonset 
		- Deployment 		


#########################
Day - 10 | 17th Nov. 2024
#########################


	- Create/Deploy Pods : with eg. 
	
	- Login to the Pod 
	
		- kubectl exec -it 
	
	- Access the Applications running inside the port using web-browser
	
		- Nodeport service 
		
		
	Create Manifest file - *.yaml

	Manifest File : --> yaml/json 
	
		apiversion:
		kind:
		metadata:
		spec:
		
	kubectl describe		# Used analyze the kubernetes objects
	

		- Nodeport service  ==> 30000 to 32767 
		

	Controller Objects 
	
		- Replication Controller 
		- Replicaset 
		- Daemonset 
		- Deployment 
		
		
		Replication Controller and Replicasets ::
		
			- Both RC and RS are used to create replicas of pods.
			- Scale-up / Scale-Down
			- It is used to create the replicas of pods and deploy in the cluster.
			- It is used to run the specific number of pods
			
			RC uses the equality based operator 
								Environment = "QA"
								Environment = "DEV"
			RS uses the Set based operator 
								Environment : {"DEV","QA","UAT"}
								
			RS is based on RC 
			
			Replicaset can be created automatically when we create Deployment Controller Object.
			
			
			kubectl create -f nginx-rc.yaml
			
			kubectl apply -f nginx-rc.yaml
			
			- Scale-up / Scale-Down ::::
			
				replicas : 3 
				
				Micro-service1 ==> 
				
				10 Replicas of pods ==> 100 Users  ++ 1000 users?
				
				+10 Replicas
			
		- Daemonset :
		
			- Is used to execute a copy of pod in all the available nodes.
			- If any new nodes are added to the cluster, Daemonset will deploy the new pod instance in that node.
			- If any node gets deleted, Daemonset will automatically delete that pod instance.
			- Deletion of Daemonset will delete all the associated pod instances
			
			

		
		- Deployment Controller Objects ::
		
			Deployment Controller Object :::
			
				--> It is used to deploy the pods and ensure high availability of pods by creating pod replicas 
				--> 1. Create Muliple instance/replicas/copies of pods 
					2. Used to Scale-Up / Scale-Down the Pods 
					3. Used to Upgrade the application pods 
					4. Used to Down-grade/roll-back the application pods
				--> The upgrade/down-grade of application pods can be done without any downtime. 
				--> To achieve zero-downtime during upgrade/down-grade, By Default, it used Rolling-Update Deployment Strategy.
				
				
			Rolling-Update Deployment Strategy
			
				- p1 ==> v1.0 ==> v2.0
				
				- p2 ==> v1.0
				
				- p3 ==> v1.0
				
			Blue - Green 
			
			Canary Deployment 
			
			
		Deployment Object 
		
		Replicaset 
		
		Pod Instances 
		
		
		
		Kubernetes Volumes :
		
			- ConfigMap Volume
				- Config Map Volume is used pass the config file as a input 
				- Used to share the non-sensitive data files.
				- Used to access the file content even outside the Pod.
				- It is applicable at the Cluster Level. 
				
			- Secret Volume 
				- Secret Volume  Volume is used pass the encypted Pod Secrets as a input 
				- Used to share the sensitive data files.			
				- Used to access the file content only with the pod.
				- It is applicable at the Cluster Level. 

			
			- HostPath Volume 
				- Is same as like Docker Volume
				- Volume will be created in the Host Machine during Deployment
			
			
		What is Application Image?
		Containerization ?
		
Next :::		
	- Persistant Volumes 
	- Persistant Volume Claim 
	
	- Kubernetes Services
	
	- Namespaces 
	
	- Helm Charts




##########################
Day - 11 | 23rd Nov. 2024
##########################

	- Persistant Volumes 
	- Persistant Volume Claim 
	
	- Kubernetes Services
	
	- Namespaces 
	
	- Helm Charts
	
		- Create Kubernetes Dashboard using Helm
		
		
	- Persistant Volumes 
	
		-> Static vs Dynamic Provisioning 
			
	- Persistant Volume Claim 		

		
	- Kubernetes Services :::
	
		- NodePort Service 
		
		- ClusterIP 
		
		- Load Balancer Service (External Service from Service Provider - Managed Service)
		
		- Ingress Controller 
		
		
	
	
	
		POD -> Web Application :::
		
			Node Port Service ::::
			
			
			
			Front-End Pods		

					fp1,2,3,4,5
			
			
			Back-End Pods 
					bp1,2,3,4,5
					
					
					
	
	
	
	
		www.google.com 						===> 	Load Balancer URL 
		
			Services :
			
				Maps 
				Translate 
				Drive 
				mail 
				
	
		Kubernetes Ingress Controller :::
		
			- Using the Rules :
			
			
			Rules to Route the Request

				- Simple Routing 		==> 		--> Blog Sites / Article Pages - Static Web Pages <IP/DNS>
				
				- Host Based Routing 
				
				- Path Based Routing 

				www.google.com 								- Host Based Routing 
					
				
				Maps 	==> 	www.maps.google.com
				
				translate ==>	www.translate.google.com 
				
				mail 		==> www.mail.google.com 		- Path Based Routing
			
			
								Inbox 					www.mail.google.com/inbox 	==> NodePort_Svc1
								
								sent 					www.mail.google.com/sent 	==> NodePort_Svc2
								
								trash 					www.mail.google.com/trash 	==> NodePort_Svc3
		
		
	
	
	
	End-User	----	Load-Balancer	---		Ingress_Controller		----		www.mail.google.com/inbox
												(Compose of Rules)					www.mail.google.com/sent
																					www.mail.google.com/trash
					
					


	- Namespaces ::::
	
		Cluster :	WN1,2,3,4,5,6
		
		Namespace 		# It is a Logical Partitioning of Kubernetes Cluster 
		
		
		Kubernetes ::
		
			kubectl get pods :
			
			
				 It will get the list of pods from default namespace 
				 
			
			kubectl get ns :
			
				 To get the list of Namespaces 
				 
				 
				 default 
				 kube-flannel 
				 kube-system 
				 
				 
			kubectl get pods --all-namespaces
			
			
			kubectl create namespace DEV  
		
			kubectl create namespace QA 

			kubectl create namespace UAT  
			
			kubectl get pods --namespace dev 
			
		

	Production Environment :::

	
		Production Servers : 1,2,3,4,5 
		
		Prod_Servers_ACTIVE 			: 1,2,3,4,5 			--> mywebapp:v1.0			==> Stop 
		
		
		Application Upgrade :::		mywebapp:v2.0
		
							  
		Prod_Servers_PASSIVE 			: 1,2,3,4,5 			--> mywebapp:v2.0			==> ACTIVE 



		
		Blue-Green Deployment Strategy :::
		
		Prod_Kubernetes_Cluster :
		
				: WN1,2,3,4,5,6				--> 	mywebapp:v1.0	

						Create NameSpace :
						
							MywebappnsV1	-->     mywebapp:v1.0	
		
							  
		Application Upgrade :::		mywebapp:v2.0
		
		
				: WN1,2,3,4,5,6				--> mywebapp:v2.0		


		Kubernetes Namespace 
		
							MywebappnsV2	-->     mywebapp:v2.0
		
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  namespace: prodnsv2
  labels:
    app: nginx
    tier: dev
spec:
  containers:
  - name: nginx-container
    image: nginx

    ports:
    - containerPort: 80





	
		
		Cluster :	WN1,2,3,4,5,6
		
		Non-Prod Kubernetes Cluster :
		
			master 
			
				WN1,2,3,4,5
		

Next :

		- Helm Charts
	
		- Create Kubernetes Dashboard using Helm
